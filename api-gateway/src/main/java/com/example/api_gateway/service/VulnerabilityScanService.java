package com.example.api_gateway.service;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import javax.annotation.PreDestroy;
import reactor.core.publisher.Mono;

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;

@Service
public class VulnerabilityScanService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityScanService.class);
    private final Map<String, ScanStatus> scanStatuses = new ConcurrentHashMap<>();
    private final Map<String, String> scanReports = new ConcurrentHashMap<>();

    private static class ScanStatus {
        String status; // "RUNNING", "COMPLETED", "FAILED"
        Process process;
        File outputFile;
        long startTime;
        int timeoutSeconds;
    }

    public Mono<Map<String, Object>> triggerScan(Map<String, Object> scanConfig) {
        return Mono.fromCallable(() -> {
            String scanId = UUID.randomUUID().toString();
            String sourceDir = (String) scanConfig.getOrDefault("sourceDir", ".");
            String rulesDir = (String) scanConfig.getOrDefault("rulesDir", "rules");
            String outputPath = (String) scanConfig.getOrDefault("outputPath",
                    "reports/scan_" + scanId + ".json");
            int timeout = (int) scanConfig.getOrDefault("timeout", 300);
            boolean useSemgrep = (boolean) scanConfig.getOrDefault("useSemgrep", false);

            logger.info("Initiating scan. ID: {}, Source: {}, Rules: {}, Output: {}, Timeout: {}, Semgrep: {}",
                    scanId, sourceDir, rulesDir, outputPath, timeout, useSemgrep);

            // Ensure output directory exists
            Path outputDir = Paths.get(outputPath).getParent();
            if (outputDir != null) {
                Files.createDirectories(outputDir);
            }

            // Build the Go command
            List<String> command = new ArrayList<>(List.of(
                    "go", "run", "main.go",
                    "--source", sourceDir,
                    "--rules", rulesDir,
                    "--output", outputPath,
                    "--timeout", String.valueOf(timeout)
            ));
            if (useSemgrep) {
                command.add("--semgrep-registry");
            }

            ProcessBuilder pb = new ProcessBuilder(command);
            pb.directory(new File("/home/arjun/Desktop/J-Sentinel/rule-engine/"));
            pb.redirectErrorStream(true);

            // Create scan status
            ScanStatus status = new ScanStatus();
            status.status = "RUNNING";
            status.outputFile = new File(outputPath);
            status.timeoutSeconds = timeout;
            status.startTime = System.currentTimeMillis();

            try {
                status.process = pb.start();
                scanStatuses.put(scanId, status);

                // Start monitoring thread
                new Thread(() -> {
                    try (
                        BufferedReader reader = new BufferedReader(
                            new InputStreamReader(status.process.getInputStream()))
                    ) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            logger.info("[{}] {}", scanId, line); // Real-time log output
                        }

                        boolean finished = status.process.waitFor(timeout, TimeUnit.SECONDS);
                        int exitCode = status.process.exitValue();

                        if (finished && exitCode == 0) {
                            status.status = "COMPLETED";
                            String reportContent = new String(Files.readAllBytes(status.outputFile.toPath()));
                            scanReports.put(scanId, reportContent);
                            logger.info("Scan {} completed successfully.", scanId);
                        } else {
                            status.status = "FAILED";
                            logger.warn("Scan {} failed. ExitCode: {}, TimedOut: {}", scanId, exitCode, !finished);
                            if (!finished) {
                                status.process.destroyForcibly();
                            }
                        }
                    } catch (Exception e) {
                        logger.error("Exception while running scan process for ID {}", scanId, e);
                        status.status = "FAILED";
                    } finally {
                        scanStatuses.remove(scanId);
                    }
                }).start();

                return Map.of(
                        "scanId", scanId,
                        "status", "STARTED",
                        "message", "Scan initiated successfully"
                );
            } catch (IOException e) {
                logger.error("Failed to start scan process", e);
                throw new RuntimeException("Failed to start scan: " + e.getMessage());
            }
        });
    }

    public Mono<Map<String, Object>> getScanStatus(String scanId) {
        return Mono.fromCallable(() -> {
            ScanStatus status = scanStatuses.get(scanId);
            if (status == null) {
                if (scanReports.containsKey(scanId)) {
                    return Map.of(
                        "scanId", scanId,
                        "status", "COMPLETED",
                        "reportAvailable", true
                    );
                }
                return null;
            }

            if ("RUNNING".equals(status.status) && !status.process.isAlive()) {
                status.status = "FAILED";
            }

            Map<String, Object> result = new HashMap<>();
            result.put("scanId", scanId);
            result.put("status", status.status);
            if ("COMPLETED".equals(status.status)) {
                result.put("reportAvailable", true);
            }

            return result;
        });
    }

    public Mono<Map<String, Object>> getScanReport(String scanId) {
        return Mono.fromCallable(() -> {
            String report = scanReports.get(scanId);
            if (report == null) return null;
            return new JSONObject(report).toMap(); // return full JSON as top-level response
        });
    }

    @PreDestroy
    public void cleanup() {
        logger.info("Cleaning up active scan processes...");
        scanStatuses.forEach((scanId, status) -> {
            if (status.process != null && status.process.isAlive()) {
                logger.info("Killing scan process: {}", scanId);
                status.process.destroy();
            }
        });
        scanStatuses.clear();
        scanReports.clear();
    }
}
