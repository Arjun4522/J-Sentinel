package com.example.api_gateway.service;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import javax.annotation.PreDestroy;
import java.io.*;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.concurrent.*;

@Service
public class VulnerabilityScanService {

    private static final Logger logger = LoggerFactory.getLogger(VulnerabilityScanService.class);
    private final Map<String, ScanStatus> scanStatuses = new ConcurrentHashMap<>();
    private final Map<String, String> scanReports = new ConcurrentHashMap<>();

    @Autowired(required = false)
    private ScanMetadataStore metadataStore;

    private static class ScanStatus {
        String status;
        Process process;
        File outputFile;
        long startTime;
        int timeoutSeconds;
    }

    public Mono<Map<String, Object>> triggerScan(Map<String, Object> scanConfig) {
        return Mono.fromCallable(() -> {
            String scanId = (String) scanConfig.getOrDefault("scanId", UUID.randomUUID().toString());
            String sourceDir = (String) scanConfig.getOrDefault("sourceDir", ".");
            String rulesDir = (String) scanConfig.getOrDefault("rulesDir", "rules");
            String outputPath = (String) scanConfig.getOrDefault("outputPath", "reports/scan_" + scanId + ".json");
            int timeout = (int) scanConfig.getOrDefault("timeout", 300);
            boolean useSemgrep = (boolean) scanConfig.getOrDefault("useSemgrep", false);

            logger.info("Initiating scan. ID: {}, Output: {}", scanId, outputPath);

            Path outputDir = Paths.get(outputPath).getParent();
            if (outputDir != null) Files.createDirectories(outputDir);

            List<String> command = new ArrayList<>(List.of(
                    "./detect",
                    "--source", sourceDir,
                    "--rules", rulesDir,
                    "--output", outputPath,
                    "--timeout", String.valueOf(timeout),
                    "--scan_id", scanId // Fixed: Split --scan_id and value
            ));
            if (useSemgrep) command.add("--semgrep-registry");

            ProcessBuilder pb = new ProcessBuilder(command);
            pb.directory(new File("/home/arjun/Desktop/J-Sentinel/rule-engine"));
            pb.redirectErrorStream(true);

            ScanStatus status = new ScanStatus();
            status.status = "RUNNING";
            status.outputFile = new File(outputPath);
            status.timeoutSeconds = timeout;
            status.startTime = System.currentTimeMillis();

            try {
                status.process = pb.start();
                scanStatuses.put(scanId, status);

                new Thread(() -> {
                    try (BufferedReader reader = new BufferedReader(
                            new InputStreamReader(status.process.getInputStream()))) {
                        String line;
                        while ((line = reader.readLine()) != null) {
                            logger.info("[{}] {}", scanId, line);
                        }

                        boolean finished = status.process.waitFor(timeout, TimeUnit.SECONDS);
                        int exitCode = status.process.exitValue();

                        if (finished && exitCode == 0) {
                            if (status.outputFile.exists()) {
                                status.status = "COMPLETED";
                                String reportContent = Files.readString(status.outputFile.toPath());
                                scanReports.put(scanId, reportContent);
                                logger.info("Scan {} completed successfully.", scanId);

                                if (metadataStore != null) {
                                    metadataStore.saveReport(scanId, reportContent);

                                    JSONObject json = new JSONObject(reportContent);
                                    JSONObject stats = json.optJSONObject("statistics");

                                    int filesProcessed = stats != null ? stats.optInt("files_processed", 0) : 0;
                                    int vulnerabilitiesFound = stats != null ? stats.optInt("vulnerabilities_found", 0) : 0;

                                    ScanMetadataStore.ScanMetadata metadata = metadataStore.getMetadata(scanId);
                                    if (metadata != null) {
                                        metadata.setStatus("COMPLETED");
                                        metadata.setEndTime(System.currentTimeMillis());
                                        metadata.setFilesProcessed(filesProcessed);
                                        metadata.setVulnerabilitiesFound(vulnerabilitiesFound);
                                        metadataStore.saveMetadata(scanId, metadata);
                                    }
                                }
                            } else {
                                status.status = "FAILED";
                                logger.error("Scan {} completed but report file not found at path: {}",
                                        scanId, status.outputFile.getAbsolutePath());
                            }
                        } else {
                            status.status = "FAILED";
                            logger.warn("Scan {} failed. ExitCode: {}, TimedOut: {}", scanId, exitCode, !finished);
                            if (!finished) status.process.destroyForcibly();
                        }
                    } catch (Exception e) {
                        logger.error("Exception while running scan process for ID {}", scanId, e);
                        status.status = "FAILED";
                    } finally {
                        scanStatuses.remove(scanId);
                    }
                }).start();

                return Map.of(
                        "scanId", scanId,
                        "status", "STARTED",
                        "message", "Scan initiated successfully"
                );
            } catch (IOException e) {
                logger.error("Failed to start scan process", e);
                throw new RuntimeException("Failed to start scan: " + e.getMessage());
            }
        });
    }

    public Mono<Map<String, Object>> getScanStatus(String scanId) {
        return Mono.fromCallable(() -> {
            ScanStatus status = scanStatuses.get(scanId);
            if (status == null) {
                if (scanReports.containsKey(scanId)) {
                    return Map.of(
                            "scanId", scanId,
                            "status", "COMPLETED",
                            "reportAvailable", true
                    );
                }
                return null;
            }

            if ("RUNNING".equals(status.status) && !status.process.isAlive()) {
                status.status = "FAILED";
            }

            Map<String, Object> result = new HashMap<>();
            result.put("scanId", scanId);
            result.put("status", status.status);
            result.put("reportAvailable", "COMPLETED".equals(status.status));

            return result;
        });
    }

    public Mono<Map<String, Object>> getScanReport(String scanId) {
        return Mono.fromCallable(() -> {
            String report = scanReports.get(scanId);
            if (report == null) return null;
            return new JSONObject(report).toMap();
        });
    }

    @PreDestroy
    public void cleanup() {
        logger.info("Cleaning up active scan processes...");
        scanStatuses.forEach((scanId, status) -> {
            if (status.process != null && status.process.isAlive()) {
                logger.info("Killing scan process: {}", scanId);
                status.process.destroy();
            }
        });
        scanStatuses.clear();
        scanReports.clear();
    }
}