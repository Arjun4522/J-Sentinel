package com.example.api_gateway.service;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.io.File;
import java.nio.file.Files;
import java.util.Map;
import java.util.UUID;

@Primary
@Service
public class TrackedVulnerabilityScanService extends VulnerabilityScanService {

    private static final Logger logger = LoggerFactory.getLogger(TrackedVulnerabilityScanService.class);

    private final ScanMetadataStore metadataStore;

    public TrackedVulnerabilityScanService(ScanMetadataStore metadataStore) {
        this.metadataStore = metadataStore;
    }

    @Override
    public Mono<Map<String, Object>> triggerScan(Map<String, Object> scanConfig) {
        String scanId = UUID.randomUUID().toString();
        String sourceDir = (String) scanConfig.getOrDefault("sourceDir", ".");
        String rulesDir = (String) scanConfig.getOrDefault("rulesDir", "rules");

        String outputPath = "/home/arjun/Desktop/J-Sentinel/rule-engine/reports/scan_" + scanId + ".json";

        // Update config to pass to base service
        scanConfig.put("scanId", scanId);
        scanConfig.put("outputPath", outputPath);

        // Save metadata initially
        ScanMetadataStore.ScanMetadata metadata = new ScanMetadataStore.ScanMetadata(
                scanId, sourceDir, rulesDir, System.currentTimeMillis(), "STARTED", 0, 0
        );
        metadataStore.saveMetadata(scanId, metadata);

        return super.triggerScan(scanConfig)
                .map(result -> {
                    monitorMetadataAfterScan(scanId, outputPath);
                    return result;
                });
    }

    private void monitorMetadataAfterScan(String scanId, String outputPath) {
        new Thread(() -> {
            try {
                File outputFile = new File(outputPath);
                int retries = 0;
                while (!outputFile.exists() && retries++ < 60) {
                    Thread.sleep(1000);
                }

                if (!outputFile.exists()) {
                    metadataStore.updateStatus(scanId, "FAILED");
                    logger.error("Scan {}: Report file still not found after waiting.", scanId);
                    return;
                }

                String reportContent = Files.readString(outputFile.toPath());
                metadataStore.saveReport(scanId, reportContent);

                JSONObject json = new JSONObject(reportContent);
                int filesProcessed = json.optJSONObject("summary") != null
                        ? json.getJSONObject("summary").optInt("filesProcessed", 0) : 0;
                int vulnerabilitiesFound = json.optJSONObject("summary") != null
                        ? json.getJSONObject("summary").optInt("vulnerabilitiesFound", 0) : 0;

                ScanMetadataStore.ScanMetadata metadata = metadataStore.getMetadata(scanId);
                if (metadata != null) {
                    metadata.setStatus("COMPLETED");
                    metadata.setEndTime(System.currentTimeMillis());
                    metadata.setFilesProcessed(filesProcessed);
                    metadata.setVulnerabilitiesFound(vulnerabilitiesFound);
                }

                logger.info("Scan {} metadata updated: {} files, {} vulns",
                        scanId, filesProcessed, vulnerabilitiesFound);

            } catch (Exception e) {
                logger.error("Error updating metadata for scan {}", scanId, e);
                metadataStore.updateStatus(scanId, "FAILED");
            }
        }).start();
    }
}
