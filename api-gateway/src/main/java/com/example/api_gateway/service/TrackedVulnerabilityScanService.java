package com.example.api_gateway.service;

import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.io.File;
import java.nio.file.Files;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

@Primary
@Service
public class TrackedVulnerabilityScanService extends VulnerabilityScanService {

    private static final Logger logger = LoggerFactory.getLogger(TrackedVulnerabilityScanService.class);

    private final ScanMetadataStore metadataStore;

    public TrackedVulnerabilityScanService(ScanMetadataStore metadataStore) {
        this.metadataStore = metadataStore;
    }

    @Override
    public Mono<Map<String, Object>> triggerScan(Map<String, Object> scanConfig) {
        String scanId = UUID.randomUUID().toString();
        String sourceDir = (String) scanConfig.getOrDefault("sourceDir", ".");
        String rulesDir = (String) scanConfig.getOrDefault("rulesDir", "rules");
        String outputPath = "/home/arjun/Desktop/J-Sentinel/rule-engine/reports/" + scanId + ".json";

        scanConfig.put("scanId", scanId);
        scanConfig.put("outputPath", outputPath);

        // Initialize metadata with all required fields
        ScanMetadataStore.ScanMetadata metadata = new ScanMetadataStore.ScanMetadata(
                scanId, 
                sourceDir, 
                rulesDir, 
                System.currentTimeMillis(), 
                "STARTED", 
                0, 
                0
        );
        metadataStore.saveMetadata(scanId, metadata);

        return super.triggerScan(scanConfig)
                .doOnSuccess(result -> {
                    CompletableFuture.runAsync(() -> {
                        monitorMetadataAfterScan(scanId, outputPath, sourceDir, rulesDir);
                    });
                });
    }

    private void monitorMetadataAfterScan(String scanId, String outputPath, String sourceDir, String rulesDir) {
        try {
            File outputFile = new File(outputPath);
            int waited = 0;
            int maxWaitMillis = 1000000;
            
            while (!outputFile.exists() && waited < maxWaitMillis) {
                Thread.sleep(1000);
                waited += 1000;
            }

            if (!outputFile.exists()) {
                metadataStore.updateStatus(scanId, "FAILED");
                logger.error("Scan {}: Report file not found after waiting.", scanId);
                return;
            }

            String reportContent = Files.readString(outputFile.toPath());
            metadataStore.saveReport(scanId, reportContent);

            JSONObject json = new JSONObject(reportContent);
            int filesProcessed = 0;
            int vulnerabilitiesFound = 0;

            if (json.has("statistics")) {
                JSONObject stats = json.getJSONObject("statistics");
                filesProcessed = stats.optInt("files_processed", 0);
                vulnerabilitiesFound = stats.optInt("vulnerabilities_found", 0);
            } else if (json.has("summary")) {
                JSONObject summary = json.getJSONObject("summary");
                vulnerabilitiesFound = summary.optInt("total_vulnerabilities", 0);
            }

            // Create new metadata with all fields properly set
            ScanMetadataStore.ScanMetadata newMetadata = new ScanMetadataStore.ScanMetadata(
                    scanId,
                    sourceDir,
                    rulesDir,
                    metadataStore.getMetadata(scanId).getStartTime(),
                    "COMPLETED",
                    filesProcessed,
                    vulnerabilitiesFound
            );
            newMetadata.setEndTime(System.currentTimeMillis());
            metadataStore.saveMetadata(scanId, newMetadata);

            logger.info("Scan {} metadata updated: {} files, {} vulns", scanId, filesProcessed, vulnerabilitiesFound);
        } catch (Exception e) {
            logger.error("Error updating metadata for scan {}", scanId, e);
            metadataStore.updateStatus(scanId, "FAILED");
        }
    }
}